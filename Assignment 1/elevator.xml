<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>
// constants and variable related to number of floors
const int F = 3;         // # floors
typedef int[0,F-1] id_f; // floor id from 0 to N-1

// Stolen definition from Floor declarations (above)
const int L = 3;         // # lifts
typedef int[0, L-1] id_e;// elevator ID from 0 to N-1

// constant definition for amount of channels
const int P = F * L;
typedef int[0,  P -1] id_p; // Protecting door channels

// The array has been divided by the amount of lifts, plus added one to take care of the uneven division.
// There could be less floors than lifts F&lt;L == 0, one lift F/1 = F, or more floors than there are lifts. 
// The first situation is special and requires a different subdivision.
id_e floors_per_lift(){
    int size = 0;

    if(F == 1 || F &lt; L)
    {
        size = F;
    }
    else
    {
        size = F / L;
    }

    return size;
}

typedef struct {
    id_f min;
    id_f max;
    id_f up_peak_floor;
} floors_to_serve;

int p_door_id[L][F];

// The active floor serving plan
floors_to_serve active_floor_serving_plan[L];
bool active_service = false;

// cabin door channels and constants
chan open_door[id_e], close_door[id_e], door_open[id_e], door_closed[id_e]; // channels for a door
const int door_time = 2;     // time to open or close the door

// protecting door channels and constants
chan open_pdoor[id_p], close_pdoor[id_p], pdoor_open[id_p], pdoor_closed[id_p]; // channels for a door

// engine channels
chan stop[id_e], move_down[id_e], move_up[id_e];

// floor sensors channels and constants
const int floor_time = 1; // time to travel one floor
chan start_sensors[id_e],stop_sensors[id_e],reach_floor[id_e];

// To ensure that passengers can get in and out before the doors close
int passenger_wait_time = 10;

// button channels
chan req[id_f];

// communications between RequestHandler and MainControl
chan go[id_e], served[id_e];

// Place global declarations here.

// TODO: Fix for multiple elevators

// The current floor of the elevator:
meta id_f current_floors[L]; 
// The floor to which the main control is requested to go to.
// This variable is just used for communication between the request handler and the main control.
// Therefore, we can declare it meta (i.e., not part of the state).
meta id_f target_floor[L];

void activate_service(bool active)
{
    active_service = active;
}

void reset_current_floors()
{
    for(e : id_e)
    {
        active_floor_serving_plan[e].min = 0;
        active_floor_serving_plan[e].max = 0;
        active_floor_serving_plan[e].up_peak_floor = 0;
        current_floors[e] = 0;
        target_floor[e] = 0;
    }
}

void set_protecting_floor_ids()
{
    int i = 0;

    for(x : id_e)
    {
        for(y : id_f)
        {
            p_door_id[x][y] = i;
            i++;
        }
    }
}

</declaration>
	<template>
		<name>engine</name>
		<parameter>const id_e lift_id</parameter>
		<location id="id0" x="51" y="-212">
			<committed/>
		</location>
		<location id="id1" x="-306" y="-212">
			<committed/>
		</location>
		<location id="id2" x="-127" y="-83">
			<committed/>
		</location>
		<location id="id3" x="-306" y="-51">
			<name x="-410" y="-83">moving_down</name>
		</location>
		<location id="id4" x="51" y="-51">
			<name x="59" y="-83">moving_up</name>
		</location>
		<location id="id5" x="-127" y="-212">
			<name x="-137" y="-242">Idle</name>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="68" y="-153">start_sensors[lift_id]!</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-297" y="-153">start_sensors[lift_id]!</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-119" y="-153">stop_sensors[lift_id]!</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-255" y="-51">stop[lift_id]?</label>
			<nail x="-127" y="-51"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-280" y="-238">move_down[lift_id]?</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-85" y="-51">stop[lift_id]?</label>
			<nail x="-127" y="-51"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-93" y="-238">move_up[lift_id]?</label>
		</transition>
	</template>
	<template>
		<name>button</name>
		<declaration>clock x;</declaration>
		<location id="id6" x="-32" y="-8">
		</location>
		<init ref="id6"/>
		<transition>
			<source ref="id6"/>
			<target ref="id6"/>
			<label kind="select" x="-48" y="-112">i : id_f</label>
			<label kind="guard" x="-48" y="-96">x &gt;=1</label>
			<label kind="synchronisation" x="-48" y="-80">req[i]!</label>
			<label kind="assignment" x="-48" y="-64">x=0</label>
			<nail x="-64" y="-48"/>
			<nail x="0" y="-48"/>
		</transition>
	</template>
	<template>
		<name>DGC_request_handler</name>
		<parameter>const int size</parameter>
		<declaration>// The dummy request handler gets requests from the button.
// When these are received, they are stored in the following local variable.
//id_f current_req;

// Before beginning with the assignment, you should take some time understand how a request is send from the button to the dummy request handler.
// This communication uses a parametrized channel "req". Basically, for each floor i there is a channel req[i].
// Another way of providing communication makes use of global variables.
// An example is the way the request handler sends a go signal to the main control.
// A global variable is used (target_floor, see "Declarations" of the project). When sending a go, the request handler puts a value into this global variable.
// When receiving a go, the main control takes this value and immediately sets it to zero. In UPPAAL, this is a very efficient way of encoding a synchronous communication.


// The dummy request handler can only deal with one request at a time.
// Only after the request has been served, a new request can be received.
// The first part of the task tells you how to build a FIFO request handler.
// This handler receives requests and stores them in a queue.
// The following code defines this queue.

// Local queue storing the requests.
typedef struct  
{
    id_f queue[size];
    int[0,size] length;
    bool active;
} fifo;

fifo queues[id_e];

// Put an element at the end of the queue
// Current allocation scheme is a FIFO
// might not be the smartest scheme but it ensures
// that all requests are served ...
// until the FIFO is full. Then it simply 
// ignores all requests. 
void enqueue(id_e lift_id, id_f element)
{
        queues[lift_id].length++;
        // Apparently the code on the next line causes errors?
        //int length = queues[lift_id].length;

        // Previous code line would have helped with readability.
        queues[lift_id].queue[queues[lift_id].length] = element;
}

// Remove the front element of the queue
void dequeue(id_e lift_id)
{
        int i = 0;
        queues[lift_id].length--;

        while (i &lt; queues[lift_id].length)
        {
                queues[lift_id].queue[i] = queues[lift_id].queue[i + 1];
                i++;
        }
        queues[lift_id].queue[i] = 0;
}

bool any_FIFO_full(){
    bool full = false;

    // TODO: Fix check 

    return full;
}

// Returns the front element of the queue
id_f front(id_e lift_id)
{
   return queues[lift_id].queue[0];
}

// Returns the last element of the queue
id_f last(id_e lift_id)
{
    fifo lift_fifo = queues[lift_id];

   return lift_fifo.queue[lift_fifo.length - 1];
}

bool is_empty(id_e lift_id)
{
	return queues[lift_id].length == 0;
}

bool is_full(id_e lift_id)
{
	return queues[lift_id].length == size;
}

// Code for checking whether the request is for a floor
bool is_request_for_lift(id_f floor_request, id_e lift_id)
{
    // Get the floor plan from the lift
    floors_to_serve service_plan = active_floor_serving_plan[lift_id];

    // The floor that needs to be served needs to be between its minimum and maximum
    return (service_plan.min &gt;= floor_request &amp;&amp; floor_request &lt;= service_plan.max);
}

int find_lift_id(id_f request)
{
    // -1 means there is no active lift
    int service_lift = -1;
    id_e current_lift = 0;
    bool serviced = false;

    do
    {
        // does the lift take requests (active means that is currently emptying queue) AND is its FIFO not full?    
        serviced = !queues[current_lift].active &amp;&amp; is_request_for_lift(request, current_lift) &amp;&amp; !is_full(current_lift);
        
        // We have found a lift that can service the request
        if(serviced)
        {
            // Set the lift_id to the current iteration
            service_lift = current_lift;
        }
        
        // Make sure we cannot go out of bounds
        if(current_lift + 1 &gt;= L)
        {
            serviced = true; // Failed to service this request, no lifts available
            
        }
        else
            current_lift++; // Iterate over remaining lift(s)
     }
     while(!serviced); // Make sure we only continue iterating if we have not found a lift that can service

    // -1 = no lift available, service_lift &gt; -1 = lift found
    return service_lift;
}

void receive_request(id_f request)
{
    // This is not allowed in UPPAAL?
    //if(!active_service)
    //{
    //    return;
    //}

    // Find the corresponding lift (if larger than -1, lift was found)
    int lift_id = find_lift_id(request);

    // If the lifts are disabled or not servicing: do not accept requests
    if(active_service &amp;&amp; lift_id &gt; -1)
    {
       enqueue(lift_id, request);
    }
    else
    {
        // Create a stack and add the floor to be serviced later
    }
}

void divide_floors_per_lift(){
    // Calculate how many floors there are per left
    const int floors_per_lift = floors_per_lift();
    // the remainder to be divided amongst the lifts
    int remainder = F % L;
    
    // The floor count that have been passed (currently none)
    id_e current_floor = 0;

    // Go through all of the lifts (there should be no floors left afterwards


    for(i : id_e)
    {
        // Add the starting floor
        active_floor_serving_plan[i].min = current_floor;
        // End floor for this lift
        active_floor_serving_plan[i].max = current_floor + floors_per_lift - 1;
        //active_floor_serving_plan[i].max = floors_per_lift == 1 ? current_floor : current_floor +  floors_per_lift - 1;

        // Update the current maximum floor for the next lift
        current_floor += floors_per_lift - 1;

        // Equally divide the remainder of the code
        if(remainder &gt; 0)
        {
            // Update the floor serving plan with an extra remaing floor
            active_floor_serving_plan[i].max++;
            // Reduce the amount of floors remaining
            remainder--;
            
            // Update the starting floor for the next lift as well
            current_floor++;
        }
    }
}

</declaration>
		<location id="id7" x="-1572" y="-799">
		</location>
		<location id="id8" x="-1853" y="-799">
			<committed/>
		</location>
		<init ref="id8"/>
		<transition>
			<source ref="id7"/>
			<target ref="id7"/>
			<label kind="select" x="-1623" y="-1045">i : id_f</label>
			<label kind="guard" x="-1623" y="-1020">!any_FIFO_full()</label>
			<label kind="synchronisation" x="-1623" y="-1002">req[i]?</label>
			<label kind="assignment" x="-1623" y="-977">receive_request(i)</label>
			<nail x="-1700" y="-935"/>
			<nail x="-1462" y="-935"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="assignment" x="-1810" y="-884">divide_floors_per_lift(),
reset_current_floors(),
set_protecting_floor_ids(),
activate_service(true)</label>
		</transition>
	</template>
	<template>
		<name>floor_sensors</name>
		<parameter>const id_e lift_id</parameter>
		<declaration>clock x;</declaration>
		<location id="id9" x="32" y="-24">
			<name x="40" y="-72">moving</name>
			<label kind="invariant" x="40" y="-56">x &lt;= floor_time</label>
		</location>
		<location id="id10" x="-200" y="-24">
			<name x="-264" y="-16">idle</name>
		</location>
		<init ref="id10"/>
		<transition>
			<source ref="id9"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-120" y="-112">stop_sensors[lift_id]?</label>
			<nail x="32" y="-88"/>
			<nail x="-200" y="-88"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id9"/>
			<label kind="guard" x="136" y="-24">x &gt;= floor_time</label>
			<label kind="synchronisation" x="136" y="-8">reach_floor[lift_id]!</label>
			<label kind="assignment" x="136" y="8">x := 0</label>
			<nail x="128" y="-24"/>
			<nail x="128" y="32"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-128" y="-48">start_sensors[lift_id]?</label>
			<label kind="assignment" x="-104" y="-16">x := 0</label>
		</transition>
	</template>
	<template>
		<name>cabin_door</name>
		<parameter>const id_e lift_id</parameter>
		<declaration>clock x;</declaration>
		<location id="id11" x="-323" y="42">
			<committed/>
		</location>
		<location id="id12" x="170" y="42">
			<committed/>
		</location>
		<location id="id13" x="221" y="-229">
			<committed/>
		</location>
		<location id="id14" x="-323" y="-229">
			<committed/>
		</location>
		<location id="id15" x="221" y="-85">
			<name x="237" y="-93">closed</name>
		</location>
		<location id="id16" x="-96" y="-88">
			<name x="-80" y="-88">executing</name>
			<label kind="invariant" x="-80" y="-104">x &lt;= door_time</label>
		</location>
		<location id="id17" x="-323" y="-86">
			<name x="-371" y="-94">open</name>
		</location>
		<init ref="id15"/>
		<transition>
			<source ref="id16"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-365" y="59">pdoor_open[p_door_id[lift_id][current_floors[lift_id]]]?</label>
			<nail x="-102" y="42"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="-8" y="59">open_pdoor[p_door_id[lift_id][current_floors[lift_id]]]!</label>
			<nail x="-76" y="42"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="-34" y="-280">pdoor_closed[p_door_id[lift_id][current_floors[lift_id]]]?</label>
			<nail x="-76" y="-229"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="-399" y="-280">close_pdoor[p_door_id[lift_id][current_floors[lift_id]]]!</label>
			<nail x="-102" y="-229"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id17"/>
			<label kind="guard" x="-435" y="-46">x &gt;= door_time</label>
			<label kind="synchronisation" x="-459" y="-23">door_open[lift_id]!</label>
			<label kind="assignment" x="-383" y="-6">x := 0</label>
			<nail x="-323" y="-30"/>
			<nail x="-323" y="-46"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="229" y="-37">open_door[lift_id]?</label>
			<label kind="assignment" x="229" y="-13">x := 0</label>
			<nail x="221" y="42"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id15"/>
			<label kind="guard" x="229" y="-181">x &gt;= door_time</label>
			<label kind="synchronisation" x="229" y="-165">door_closed[lift_id]!</label>
			<label kind="assignment" x="229" y="-149">x := 0</label>
			<nail x="221" y="-157"/>
			<nail x="221" y="-141"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-468" y="-185">close_door[lift_id]?</label>
			<label kind="assignment" x="-395" y="-166">x := 0</label>
			<nail x="-323" y="-158"/>
			<nail x="-323" y="-166"/>
		</transition>
	</template>
	<template>
		<name>lift_control</name>
		<parameter>const id_e lift_id</parameter>
		<declaration>id_f dest_floor = 0; // the current destination

// Whether the elevator should move up or down
int floors_to_travel = 0;

// To make sure that the elevator can wait for passengers to enter and exit
clock x;

// Update the floor based on the direction of travel
void update_floor_change(){
    // Calculate the direction the lift should be updated to and set value
    current_floors[lift_id] += current_floors[lift_id] &gt; dest_floor ? -1 : 1;

    // Update the floors that still need to be traversed
    floors_to_travel -= 1;
}</declaration>
		<location id="id18" x="-790" y="-42">
			<name x="-800" y="-76">choose_direction</name>
		</location>
		<location id="id19" x="-1181" y="-255">
			<name x="-1224" y="-289">wait_for_door</name>
		</location>
		<location id="id20" x="-1326" y="-255">
			<name x="-1360" y="-289">open_doors</name>
			<committed/>
		</location>
		<location id="id21" x="-527" y="-255">
			<name x="-502" y="-263">received_destination</name>
		</location>
		<location id="id22" x="-764" y="-255">
			<name x="-774" y="-245">idle</name>
		</location>
		<location id="id23" x="-1326" y="-42">
			<name x="-1360" y="-25">lift_stopped</name>
		</location>
		<location id="id24" x="-528" y="-42">
			<name x="-502" y="-51">closing_doors</name>
		</location>
		<location id="id25" x="-977" y="-255">
			<name x="-1020" y="-238">wait_for_passenger</name>
			<label kind="invariant" x="-1062" y="-289">x &lt;= passenger_wait_time</label>
			<label kind="comments" x="-1113" y="-314">Make sure passengers can enter and exit</label>
		</location>
		<location id="id26" x="-1054" y="-42">
			<name x="-1130" y="-85">change_floors</name>
		</location>
		<location id="id27" x="-1513" y="-255">
			<name x="-1523" y="-289">wait_door_setup</name>
		</location>
		<init ref="id27"/>
		<transition>
			<source ref="id27"/>
			<target ref="id20"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id26"/>
			<label kind="guard" x="-1113" y="85">floors_to_travel &gt; 0</label>
			<label kind="synchronisation" x="-1113" y="68">reach_floor[lift_id]?</label>
			<label kind="assignment" x="-1113" y="102">update_floor_change()</label>
			<nail x="-986" y="68"/>
			<nail x="-1122" y="68"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id23"/>
			<label kind="guard" x="-1258" y="-42">floors_to_travel == 0</label>
			<label kind="synchronisation" x="-1241" y="-59">stop[lift_id]!</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id26"/>
			<label kind="guard" x="-986" y="-110">dest_floor &lt; current_floors[lift_id]</label>
			<label kind="synchronisation" x="-986" y="-93">move_down[lift_id]!</label>
			<nail x="-841" y="-93"/>
			<nail x="-1003" y="-93"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id26"/>
			<label kind="guard" x="-986" y="17">dest_floor &gt; current_floors[lift_id]</label>
			<label kind="synchronisation" x="-986" y="0">move_up[lift_id]!</label>
			<nail x="-833" y="17"/>
			<nail x="-1003" y="17"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id22"/>
			<label kind="guard" x="-960" y="-255">x &gt;= passenger_wait_time</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="-1156" y="-238">door_open[lift_id]?</label>
			<label kind="assignment" x="-1113" y="-272">x := 0</label>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="guard" x="-747" y="-348">dest_floor == current_floors[lift_id]</label>
			<label kind="synchronisation" x="-697" y="-323">served[lift_id]!</label>
			<label kind="comments" x="-773" y="-374">Destination is the same as soruce</label>
			<nail x="-527" y="-323"/>
			<nail x="-764" y="-323"/>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-739" y="-25">door_closed[lift_id]?</label>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id24"/>
			<label kind="guard" x="-511" y="-170">dest_floor != current_floors[lift_id]</label>
			<label kind="synchronisation" x="-510" y="-153">close_door[lift_id]!</label>
			<label kind="assignment" x="-511" y="-128">floors_to_travel := 
abs(current_floors[lift_id] - dest_floor)</label>
			<label kind="comments" x="-246" y="-178">Calculate the length of direction to travel in.
Since the first flor needs to be reached, 
we need the absolute value to be used.
Regular target direction would be a problem 
if 1-0 = 1 (would go up otherwise).</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-1317" y="-161">served[lift_id]!</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-1326" y="-323">open_door[lift_id]!</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-696" y="-280">go[lift_id]?</label>
			<label kind="assignment" x="-739" y="-248">dest_floor := target_floor[lift_id]</label>
		</transition>
	</template>
	<template>
		<name>protecting_door</name>
		<parameter>id_e e, id_f f</parameter>
		<declaration>clock x;</declaration>
		<location id="id28" x="-112" y="8">
			<name x="-144" y="24">executing_open</name>
			<label kind="invariant" x="-144" y="40">x &lt;= door_time</label>
		</location>
		<location id="id29" x="40" y="-96">
			<name x="56" y="-104">closed</name>
		</location>
		<location id="id30" x="-112" y="-120">
			<name x="-96" y="-120">executing</name>
			<label kind="invariant" x="-144" y="-104">x &lt;= door_time</label>
		</location>
		<location id="id31" x="-232" y="-104">
			<name x="-280" y="-112">open</name>
		</location>
		<init ref="id29"/>
		<transition>
			<source ref="id28"/>
			<target ref="id31"/>
			<label kind="guard" x="-425" y="-75">x &gt;= door_time</label>
			<label kind="synchronisation" x="-425" y="-59">pdoor_open[p_door_id[e][f]]!</label>
			<label kind="assignment" x="-425" y="-43">x := 0</label>
			<nail x="-232" y="8"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="synchronisation" x="48" y="-64">open_pdoor[p_door_id[e][f]]?</label>
			<label kind="assignment" x="48" y="-32">x := 0</label>
			<nail x="40" y="-32"/>
			<nail x="40" y="8"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id29"/>
			<label kind="guard" x="-88" y="-200">x &gt;= door_time</label>
			<label kind="synchronisation" x="-85" y="-187">pdoor_closed[p_door_id[e][f]]!</label>
			<label kind="assignment" x="-88" y="-168">x := 0</label>
			<nail x="-96" y="-152"/>
			<nail x="40" y="-152"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="-297" y="-187">close_pdoor[p_door_id[e][f]]?</label>
			<label kind="assignment" x="-200" y="-168">x := 0</label>
			<nail x="-232" y="-152"/>
			<nail x="-128" y="-152"/>
		</transition>
	</template>
	<system>// Place template instantiations here.

// Allows for scalability of amount of possible requests
const int handler_size = 5;

request_handler = DGC_request_handler(handler_size);

// From https://stackoverflow.com/questions/68366786/declaration-of-multiple-processes-from-the-same-template-in-uppaal
//bool var1[id_e]; // Have to add one to adjust the number of elevators
//bool var2[id_f]; // Have to add one to adjust the number of floors
cabin_doors(const id_e id) = cabin_door(id); // cabin_door with argument lift id (0.. N-1)
engines(const id_e id) = engine(id); // engines with argument lift id (0.. N-1)
lift_controls(const id_e id) = lift_control(id); // engines with argument lift id (0.. N-1)
//protecting_doors(const id_f id) = protecting_door(id); // engines with argument lift id (0.. N-1)
protecting_doors(const id_e l_id, const id_f f_id) = protecting_door(l_id, f_id);

//protecting_doors,
// List one or more processes to be composed into a system.
system cabin_doors, protecting_doors, engines, floor_sensors, button, request_handler, lift_controls; // instantiate P(1)..P(N) by filling the constant values from id_t range</system>
	<queries>
		<query>
			<formula>A[] not deadlock
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>
