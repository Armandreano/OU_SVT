1.3

Global

[DONE] 2023-05-08 (Not possible) - Use single clock x in global declarations 

Create Main Control

[DONE] 2023-05-08 - Move the elevator to the target floor 
[DONE] 2023-05-08 - Send out a served once the elevator has reached that floor. 
[DONE] 2023-05-08 - Control the engine and the cabin_doors.

Engine

[DONE] 2023-05-08 - The engine can be instructed to move up or down
[DONE] 2023-05-08 - Or to stop. 
[DONE] 2023-05-08 - Once the engine starts moving, it will start sensors. 
[DONE] 2023-05-08 - Each time the elevator reaches a floor, these sensors will send a reached_floor to the MainControl. 
[DONE] 2023-05-08 - When the elevator is moving up or down, the floor sensors indicate when a new floor is reached (Note that the sensors do not tell the floor number)
[DONE] 2023-05-08 - It is the task of MainControl to keep track of its current position. 

Doors

[DONE] 2023-05-08 - When the destination floor is reached, MainControl should stop the engine and open the door. 
[DONE] 2023-05-08 - Once the doors are open, the served signal can be sent to the RequestHandler. 
[DONE] 2023-05-08 - The cabin_doors can be instructed to open or close. 
[DONE] 2023-05-08 - Each floor has a protecting_door that is closed by default, and that should be open only when the elevator is standing still at that floor.
[DONE] 2023-05-08 - When the cabin_door is given the signal to close, they will first close the protecting doors of the current floor. 
[DONE] 2023-05-08 - Once these are closed, the cabin_door will be closed. 
[DONE] 2023-05-08 - For opening, it is similar. Note that the elevator cabin always waits for passengers in a state where its cabin door and the protecting door are open.

Bugs:
[DONE] 2023-05-09 - Elevator does not move down to floor 0 (use absolute)


1.4

DGC

- Model multiple elevators. This can elegantly be achieved by adding the number of elevators as a new constant of your model, in a similar way to the number of floors.
[DONE] 20023-05-09 - You can parametrize automata in the “Parameters:” field in the Editor.
- Next, the current simple RequestHandler is to be replaced by a smart one, called a DGCRequestHandler (for: Destination Group Control). 
- We consider a simple DGC policy for a so-called "up-peak" situation. 
- We describe the policy for a configuration of three elevators and nine floors (excluding the ground floor) as an example. Elevator 1 is assigned to serve floors 1, 2, and 3. Elevator 2 is assigned to serve floors 4, 5, and 6. Elevator 3 is assigned to serve floors 7, 8, and 9. 
[DONE] 2023-05-09 (This was already modeled?) - All elevators start at the ground floor (0) with their door open. 
- An elevator leaves as soon as it has 5 requests in its FIFO queue, that is, the amount of the requests to the floors served bythe elevator equals 5. 
- When all requests have been served, the elevator comes back to the ground floor. 
- To prevent from waiting for passengers forever, whenever there is at least one request, the elevator will also leave after at most max_wait time units.


Constraints

- Other than parametrization, do not change the templates of the doors, engine, sensors or the button.
[DONE] 2023-05-09 - Give names to the locations in the MainControl and DGCRequestHandler templates. This allows you to have a clearer idea of what is being done where, and it also makes it easier to understand the feedback on the model.
- Use the existing code for the queue, instead of writing a lot of code yourself.
- First, you have to make sure that requests initiated by the button are sent to the ReqHandler of the corresponding elevator. 
- To do this, formulate a function is_req_for_lift that takes as parameter a floor request and returns a bool. 
- This function should be independent of the number of elevators and floors. 
- Communication between the button and the ReqHandler can then be achieved using this function and conditional synchronous communication, one of the modelling patterns.
[DONE] 2023-05-08 (Got it, using integers) - UPPAAL allows to use the double type, but this is intended to make a different kind of models from the ones we are using in this project. DO NOT use the double type in your project.
- In the example, we show a configuration with 9 floors and 3 elevators, and assign 3 floors to each elevator. This is done because we want to assign the floors as equally as possible among the elevators, not because we want each elevator to serve exactly 3 floors.

After completing Task 1.4, you can assess yourself whether your model is sufficient to be handed in. It should satisfy the following criteria:

- It should be easy to play with different configurations, for instance, different numbers of floors or elevators. This means that – for instance – going from a model with 3 floors to a model with 4 floors should not be more work than changing the value of one parameter.
- Your model should be understandable. This means that locations, channels and functions have clear and descriptive names. 
- Any code that is used should be commented. 
- It also means that the model is small and elegant.
- Your model should satisfy the “no deadlock” property and this should be verifiable for a setting with 2 elevators and 3 floors (including the ground floor).
- If possible, all elevators should be able to serve (i.e. correctly receive and enqueue) a request for floor 0. However, if your model is not well optimized, satisfying this requirement may significantly increase the model checking times. It is thus allowed to refuse requests to floor 0 in this case; do keep in mind that the model would be “better” if it would accept also these requests.